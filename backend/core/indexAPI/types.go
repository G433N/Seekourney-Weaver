package indexAPI

import (
	"database/sql"
	"log"
	"os/exec"
	"seekourney/core/database"
	"seekourney/core/normalize"
	"seekourney/indexing"
	"seekourney/utils"
	"testing"
	"time"
)

// TODO: Structured log messages and struct
// TODO: Log should be in response body not query

// IndexerID is a unique identifier for an indexer.
// It is used to determine the port number for the indexer, with the formula:
// MININDEXERPORT + IndexerID.
// It is generated by postgres TODO: Implement this
type IndexerID uint

func (id IndexerID) GetPort() utils.Port {
	port := utils.MININDEXERPORT + utils.Port(id)
	if !indexing.IsValidPort(port) {
		panic("Invalid port number: to many indexers registered")
	}
	return port
}

func (indexer *IndexerData) start() (*RunningIndexer, error) {
	// TODO: Ping to make sure it actually started
	// TODO: Ping to make sure it is not already running
	// TODO: Use timeout instead of sleep
	// Basically what startIndexerAlready did
	args := indexer.Args
	// Hack to let us run ls command when testing to mock starting up indexer.
	if !testing.Testing() {
		args = append(indexer.Args, "--port="+indexer.ID.GetPort().String())
	}

	execCmd := exec.Command(args[0], args[1:]...)
	execCmd.Dir = indexer.ExecPath

	// TODO: Handle output
	execCmd.Stdout = nil
	execCmd.Stderr = nil

	err := execCmd.Start()
	if err != nil {
		log.Fatalf("Failed to start command: %v", err)
	}

	log.Printf("Starting indexer with command: %s %s\n", indexer.ExecPath, args)

	time.Sleep(1 * time.Second)

	return &RunningIndexer{
		ID:   indexer.ID,
		Exec: execCmd,
	}, nil
}

type Collection struct {
	UnregisteredCollection
	ID indexing.CollectionID
}

// SQL

// SQLGetName returns the name of the table in the database
func (col Collecton) SQLGetName() string {
	return "collection"
}

// SQLGetFields returns the fields to be inserted into the database
func (col Collecton) SQLGetFields() []string {
	return []string{"path", "indexer_id", "recursive", "source_type", "respect_last_modified", "normalizer"}
}

// SQLGetValues returns the values to be inserted into the database
func (col Collecton) SQLGetValues() []any {

	return []database.SQLValue{
		col.Path,
		col.IndexerID,
		col.Recursive,
		indexing.SourceTypeToStr(col.SourceType),
		col.RespectLastModified,
		col.Normalfunc,
	}
}

// SQLScan scans a row from the database into a Document
func (col Collecton) SQLScan(rows *sql.Rows) (Collecton, error) {
	var id indexing.CollectionID
	var path utils.Path
	var indexerID IndexerID
	var recursive bool
	var sourceType string
	var respectLastModified bool
	var normalizer normalize.Normalizer

	err := rows.Scan(&id, &path, &indexerID, &recursive, &sourceType, &respectLastModified, &normalizer)
	if err != nil {
		return Collecton{}, err
	}

	sourceTypeEnum, err := indexing.StrToSourceType(sourceType)
	if err != nil {
		log.Printf("Error parsing source type: %s", err)
		return Collecton{}, err
	}

	return Collecton{
		UnrequestedCollection{
			path,
			indexerID,
			sourceTypeEnum,
			recursive,
			respectLastModified,
			normalizer,
		},
		id,
	}, nil

}

func CollectionFromDB(db *sql.DB, id indexing.CollectionID) (Collecton, error) {
	var colloction Collecton

	q1 := database.Select().QueryAll()
	query := q1.From(colloction.SQLGetName()).Where("id = $1")

	insert := func(res *Collecton, col Collecton) {
		*res = col
	}

	err := database.ExecScan(
		db,
		string(query),
		&colloction,
		insert,
		id,
	)

	return colloction, err

}

type UnrequestedCollection struct {
	// Root path / start of reqursive indexing
	Path utils.Path

	// Indexer used to index this collection
	IndexerID IndexerID

	// Type of source
	SourceType indexing.SourceType

	// If true, the indexer will index Recursivevly
	Recursive bool

	// If false will always index when reindexing is requested
	RespectLastModified bool

	// What function to normalize all documents with
	Normalfunc normalize.Normalizer
}

// TODO move to better place
// RegisterCollection creates a Collection from an UnregisteredCollection
// and adds it to the database, making it available to index.
func RegisterCollection(
	db *sql.DB,
	ureqCol UnregisteredCollection,
) (Collection, error) {
	collection := Collection{
		UnregisteredCollection: ureqCol,
		ID:                     0, // TODO ID with DB and add to db
	}

	// TODO fix path formatting with slash ?

	return collection, nil
}
