package indexAPI

import (
	"database/sql"
	"log"
	"os/exec"
	"seekourney/core/normalize"
	"seekourney/indexing"
	"seekourney/utils"
	"time"
)

// TODO: Structured log messages and struct
// TODO: Log should be in response body not query

// IndexerID is a unique identifier for an indexer.
// It is used to determine the port number for the indexer, with the formula:
// MININDEXERPORT + IndexerID.
// It is generated by postgres TODO: Implement this
type IndexerID uint

func (id IndexerID) GetPort() utils.Port {
	port := utils.MININDEXERPORT + utils.Port(id)
	if !indexing.IsValidPort(port) {
		panic("Invalid port number: to many indexers registered")
	}
	return port
}

func (indexer *IndexerData) start() *RunningIndexer {
	// TODO: Ping to make sure it actually started
	// TODO: Ping to make sure it is not already running
	// TODO: Use timeout instead of sleep
	// Basically what startIndexerAlready did
	args := append(indexer.Args, "--port="+indexer.ID.GetPort().String())

	execCmd := exec.Command(indexer.ExecPath, args...)

	// TODO: Handle output
	execCmd.Stdout = nil
	execCmd.Stderr = nil

	err := execCmd.Start()
	if err != nil {
		log.Fatalf("Failed to start command: %v", err)
	}

	log.Printf("Starting indexer with command: %s %s\n", indexer.ExecPath, args)

	time.Sleep(1 * time.Second)

	return &RunningIndexer{
		ID:   indexer.ID,
		Exec: execCmd,
	}
}

type Collecton struct {
	UnrequestedCollection
	ID indexing.CollectionID
}

type UnrequestedCollection struct {
	// Root path / start of reqursive indexing
	Path utils.Path

	// Indexer used to index this collection
	IndexerID IndexerID

	// Type of source
	SourceType indexing.SourceType

	// If true, the indexer will index Recursivevly
	Recursive bool

	// If false will always index when reindexing is requested
	RespectLastModified bool

	// What function to normalize all documents with
	Normalfunc normalize.Normalizer
}

func RegisterCollection(db *sql.DB, ureqCol UnrequestedCollection) (indexing.CollectionID, error) {
	return 0, nil
}

func IndexCollection(db *sql.DB, collectionID indexing.CollectionID) (*RunningIndexer, error) {
	return nil, nil
}
