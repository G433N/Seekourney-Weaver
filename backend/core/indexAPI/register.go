package indexAPI

import (
	"database/sql"
	"encoding/json"
	"log"
	"seekourney/core/database"
	"seekourney/utils"
	"strings"
)

// See indexing_API.md for more information.

// IndexerData represents a registerd indexer
type IndexerData struct {
	ID IndexerID

	// The name of the indexer, should only be used for display purposes.
	// Is requested from the indexer when it is started, for the first time
	Name string

	// The path to the indexer executable, does not need to be unique.
	ExecPath string

	// The arguments to pass to the indexer executable,
	// does not need to be unique.
	Args []string
}

// Sql
// SQLGetName returns the name of the table in the database
func (ind IndexerData) SQLGetName() string {
	return "indexer"
}

// CREATE TABLE indexer (
//
//	id bigint PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY,
//	name text NOT NULL,
//	exec text NOT NULL,
//	args jsonb DEFAULT '{}' NOT NULL
//
// );
// SQLGetFields returns the fields to be inserted into the database
func (ind IndexerData) SQLGetFields() []string {
	return []string{
		"name",
		"exec",
		"args",
	}
}

// SQLGetValues returns the values to be inserted into the database
func (ind IndexerData) SQLGetValues() []any {

	jsonArgs, err := json.Marshal(ind.Args)

	if err != nil {
		log.Panicf("Error marshalling args: %s", err)
	}

	return []database.SQLValue{
		ind.Name,
		ind.ExecPath,
		jsonArgs,
	}
}

// SQLScan scans a row from the database into a Document
func (ind IndexerData) SQLScan(rows *sql.Rows) (IndexerData, error) {

	var id IndexerID
	var name string
	var exec string
	var argsBytes []byte

	err := rows.Scan(&id, &name, &exec, &argsBytes)
	if err != nil {
		return IndexerData{}, err
	}

	var args []string
	err = json.Unmarshal(argsBytes, &args)
	if err != nil {
		log.Printf("Error unmarshalling args: %s", err)
		return IndexerData{}, err
	}

	return IndexerData{
		ID:       id,
		Name:     name,
		ExecPath: exec,
		Args:     args,
	}, nil

}

func IndexerFromDB(db *sql.DB, id IndexerID) (IndexerData, error) {
	var indexer IndexerData

	q1 := database.Select().QueryAll()
	query := q1.From(indexer.SQLGetName()).Where("id = $1")

	insert := func(res *IndexerData, doc IndexerData) {
		*res = doc
	}

	err := database.ExecScan(
		db,
		string(query),
		&indexer,
		insert,
		id,
	)

	return indexer, err

}

const (
	_ENDPOINTPREFIX_ string = "http://localhost"
)

// isUnoccupiedPort checks if another indexer already has been registered

// RegisterIndexer adds a new indexer to the system.
// Returns the RegisterID representing the indexer and success status.
func RegisterIndexer(
	startupCMD string,
) (IndexerID, error) {

	split := strings.Split(startupCMD, " ")
	command := split[0]
	args := split[1:]

	// If this ID is used we are out of ports, so we can use this as a temporary
	// ID
	// to register the indexer.
	lastID := IndexerID(utils.MAXINDEXERPORT - utils.MININDEXERPORT)
	indexer := IndexerData{
		ID:       lastID,
		ExecPath: command,
		Args:     args,
	}

	active, err := indexer.start()
	utils.PanicOnError(err) // TODO actual error handling if test start fails

	name, err := GetRequest(active, "name")
	utils.PanicOnError(err)

	log.Printf("Indexer name: %s", name)

	_, err = GetRequest(active, "shutdown")
	utils.PanicOnError(err) // TODO actual error handling if shutdown fails

	err = active.Exec.Wait()
	utils.PanicOnError(err)

	// TODO: Add indexer to database

	indexer.Name = string(name)
	// indexer.ID = ID from database

	return 0, nil
}

// UnregisterIndexer removes an existing indexer from the system.
func UnregisterIndexer(id IndexerID) error {
	// TODO: Implement, this should remove it from the database.
	// TODO: This functonality is not an priority
	return nil
}
