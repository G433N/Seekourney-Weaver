package indexAPI

import (
	"database/sql"
	"encoding/json"
	"log"
	"seekourney/core/database"
	"seekourney/utils"
	"strings"
)

// See indexing_API.md for more information.

// IndexerData represents a registerd indexer
type IndexerData struct {
	ID IndexerID

	// The name of the indexer, should only be used for display purposes.
	// Is requested from the indexer when it is started, for the first time
	Name string

	// The path to the indexer executable, does not need to be unique.
	ExecPath string

	// The arguments to pass to the indexer executable,
	// does not need to be unique.
	Args []string

	// The port assigned to the indexer, must be a unique value between
	// utils.MININDEXERPORT and utils.MAXINDEXERPORT
	Port utils.Port
}

// Sql
// SQLGetName returns the name of the table in the database
func (ind IndexerData) SQLGetName() string {
	return "indexer"
}

// CREATE TABLE indexer (
//
//	id bigint PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY,
//	name text NOT NULL,
//	exec text NOT NULL,
//	args jsonb DEFAULT '{}' NOT NULL
//
// );
// SQLGetFields returns the fields to be inserted into the database
func (ind IndexerData) SQLGetFields() []string {
	return []string{
		"name",
		"exec",
		"args",
		"port",
	}
}

// SQLGetValues returns the values to be inserted into the database
func (ind IndexerData) SQLGetValues() []any {

	jsonArgs, err := json.Marshal(ind.Args)

	if err != nil {
		log.Panicf("Error marshalling args: %s", err)
	}

	return []database.SQLValue{
		ind.ID,
		ind.Name,
		ind.ExecPath,
		jsonArgs,
		ind.Port,
	}
}

// SQLScan scans a row from the database into a Document
func (ind IndexerData) SQLScan(rows *sql.Rows) (IndexerData, error) {

	var id IndexerID
	var name string
	var exec string
	var argsBytes []byte
	var port utils.Port

	err := rows.Scan(&id, &name, &exec, &argsBytes)
	if err != nil {
		return IndexerData{}, err
	}

	var args []string
	err = json.Unmarshal(argsBytes, &args)
	if err != nil {
		log.Printf("Error unmarshalling args: %s", err)
		return IndexerData{}, err
	}

	return IndexerData{
		ID:       id,
		Name:     name,
		ExecPath: exec,
		Args:     args,
		Port:     port,
	}, nil

}

func IndexerFromDB(db *sql.DB, id IndexerID) (IndexerData, error) {
	var indexer IndexerData

	q1 := database.Select().QueryAll()
	query := q1.From(indexer.SQLGetName()).Where("id = $1")

	insert := func(res *IndexerData, doc IndexerData) {
		*res = doc
	}

	err := database.ExecScan(
		db,
		string(query),
		&indexer,
		insert,
		id,
	)

	return indexer, err

}

const (
	_ENDPOINTPREFIX_ string = "http://localhost"
)

// GeneratePort generates a valid port value by finding the lowest int not
// already taken
// TODO: does not check for maximum value (nominally 500 but unsure if this is a
// hard constraint)
func generatePort(db *sql.DB) utils.Port {
	query := "SELECT t1.port + 1 " +
		"FROM indexer t1 " +
		"WHERE NOT EXISTS(SELECT * FROM indexer t2 WHERE t2.port = t1.port + 1 " +
		"AND t2.port > " + utils.MININDEXERPORT.String() + ") " +
		"ORDER BY t1.port LIMIT 1"

	rows, err := db.Query(query)
	utils.PanicOnError(err)
	defer rows.Close()

	var result utils.Port
	// if no indexers in table, will receive empty rows
	notEmpty := rows.Next()
	if notEmpty {
		err = rows.Scan(&result)
		utils.PanicOnError(err)
	} else {
		result = utils.MININDEXERPORT
	}

	return result
}

// isUnoccupiedPort checks if another indexer already has been registered

// RegisterIndexer adds a new indexer to the system.
// Returns the RegisterID representing the indexer and success status.
func RegisterIndexer(
	db *sql.DB,
	startupCMD string,
) (IndexerID, error) {

	split := strings.Split(startupCMD, " ")
	command := split[0]
	args := split[1:]

	port := generatePort(db)

	// If this ID is used we are out of ports, so we can use this as a temporary
	// ID to register the indexer.
	indexer := IndexerData{
		ID:       IndexerID(database.GenerateId()),
		ExecPath: command,
		Args:     args,
		Port:     port,
	}

	active, err := indexer.start()
	utils.PanicOnError(err) // TODO actual error handling if test start fails

	name, err := GetRequest(active, "name")
	utils.PanicOnError(err)

	indexer.Name = string(name)

	log.Printf("Indexer name: %s", name)

	_, err = GetRequest(active, "shutdown")
	utils.PanicOnError(err) // TODO actual error handling if shutdown fails
	// TODO: Fix this, the indexer shutsdown before ansering

	err = active.Exec.Wait()
	utils.PanicOnError(err)

	_, err = database.InsertInto(db, indexer)
	if err != nil {
		log.Fatalf("Error inserting indexer: %s\n", err)
	}

	return indexer.ID, nil
}

// UnregisterIndexer removes an existing indexer from the system.
func UnregisterIndexer(id IndexerID) error {
	// TODO: Implement, this should remove it from the database.
	// TODO: This functonality is not an priority
	return nil
}
