package server

import (
	"database/sql"
	"errors"
	"fmt"
	"io"
	"time"

	"github.com/lib/pq"
)

// Used for database enumerable type, can be either 'web' or 'file'
type PathType string

const (
	PathTypeWeb  PathType = "web"
	PathTypeFile PathType = "file"
)

type JSONString string

type Page struct {
	id       int64
	path     string
	pathType PathType
	dict     JSONString
}

// Prints the values of a page to a string
func pageString(page Page) string {
	return fmt.Sprintf("id: %d, \npath: %s, \npathType: %s, \ndict: %s",
		page.id, page.path, page.pathType, page.dict)
}

// Attempts to connect to the database, will retry every half second for
// 5 seconds in case the docker container is still starting up.
// Returns a pointer to a database file descriptor if the connection succeeds.
// Panics with an error if it fails to connect.
func connectToDB() *sql.DB {
	retries := 10

	psqlconn := fmt.Sprintf(
		"host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)

	fmt.Print("Waiting for database.")
	for range retries {
		db, _ := sql.Open("postgres", psqlconn)
		if err := db.Ping(); err == nil {
			fmt.Println("\nDatabase ready")
			return db
		}
		time.Sleep(500 * time.Millisecond)
		fmt.Print(".")
	}
	fmt.Print("\n")
	panic("Could not connect to database, check docker.log for more info")
}

// Panics if error is not nil
func checkSQLError(err error) {
	if err != nil {
		panic(err)
	}
}

// Inserts a row to the database.
// Ignores id of page as this is automatically generated by the database
func insertRow(db *sql.DB, page Page) (sql.Result, error) {
	const insert = `INSERT INTO "page"("path", "type", "dict") values($1, $2, $3)`
	if page.path == "" || page.pathType == "" {
		return nil, errors.New("insertion error, found empty string")
	}
	if page.dict == "" {
		page.dict = emptyJSON
	}
	fmt.Printf("%s (%s, %s, %s)\n", insert, page.path, page.pathType, page.dict)
	return db.Exec(insert, page.path, page.pathType, page.dict)
}

// func insertRowWithJSON(db *sql.DB, page Page) (sql.Result, error) {
// 	insertStmt := `INSERT INTO "page"("path", "type", "dict") values($1, $2,
// $3)`
// 	return db.Exec(insertStmt, page.path, page.pathType, page.dict)
// }

// Writes the contents of database rows to the given writer
func writeRows(writer io.Writer, rows *sql.Rows) {
	for rows.Next() {
		var page Page

		err := rows.Scan(&page.id, &page.path, &page.pathType, &page.dict)
		checkSQLError(err)

		fmt.Fprint(writer, pageString(page), "\n\n")
	}
}

// Querys the database for rows containing ALL the given keys.
// Returns a pointer to Rows that needs to be closed
func queryJSONKeysAll(db *sql.DB, keys []string) *sql.Rows {
	const query = `SELECT * FROM page WHERE dict ?& $1`

	if len(keys) == 0 {
		panic(`No keys given`)
	}

	fmt.Printf("%s (%s)\n", query, keys)

	rows, err := db.Query(query, pq.StringArray(keys))
	checkSQLError(err)

	return rows
}

// Querys the database for all rows.
// Returns a pointer to Rows that needs to be closed
func queryAll(db *sql.DB) *sql.Rows {
	const query = `SELECT * FROM page`

	fmt.Printf("%s\n", query)

	rows, err := db.Query(query)
	checkSQLError(err)

	return rows
}

// // Gets a row by its unique id
// func getRowById(db *sql.DB, id int64) (Page, bool) {
// 	var page Page
// 	const query = `SELECT * FROM page WHERE id = $1`

// 	fmt.Printf("%s (%d)\n", query, id)

// 	rows, err := db.Query(query, id)
// 	checkSQLError(err)
// 	defer rows.Close()

// 	if rows.Next() {
// 		err = rows.Scan(&page.id, &page.path, &page.pathType, &page.dict)
// 		checkSQLError(err)
// 		return page, true
// 	} else {
// 		return page, false
// 	}
// }

// Gets a row by its unique path
func getRowByPath(db *sql.DB, path string) (Page, bool) {
	var page Page
	const query = `SELECT * FROM page WHERE path = $1`

	fmt.Printf("%s (%s)\n", query, path)

	rows, err := db.Query(query, path)
	checkSQLError(err)
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(&page.id, &page.path, &page.pathType, &page.dict)
		checkSQLError(err)
		return page, true
	} else {
		return page, false
	}
}
